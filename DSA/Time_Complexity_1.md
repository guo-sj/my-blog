# Time Complexity 1  时间复杂度 (1)

## 前言
记录一下最近学习的关于`时间复杂度`的相关概念。

## 三个符号 O(n), Ω(n), Θ(n)
- n: 输入数据的数量
- O(n): 表达一个算法运行时间的上限，即算法运行的最坏情况（如，将一个顺序排列的数组进行逆序排序）。
- Ω(n): 表达一个算法运行时间的下限，即算法运行的最好情况（如，将一个顺序排列的数组进行顺序排序）
- Θ(n): 表达一个算法的上下限相等，即**O(n) = Ω(n) = Θ(n)**

## 各种情况的时间复杂度
- T: 一段程序总的运行时间， 
- t: 单个语句的运行时间

### Sequential Statement
这种情况下，程序执行语句的数量与输入数据的数量无关。例如：

```c
int add(int a, int b)
{
    return a+b;
}
```

此时，程序总的运行时间为：

```
T(n) = t(statement1) + t(statement2) + ... + t(statementN)
```
上述可知，程序总的运行时间与`n`无关，所以时间复杂度为O(1)。

### Conditional Statement
一般程序中都会含有**if-else**语句，例如：

```c
if (isValid) {
   statement1;
   statement2;
} 
else 
   statement3;
```

此时，程序总的运行时间为：

```
T(n) = max {[t(statement1)+t(statement2)], t(statement3)}
```
注意，因为`O(n)`是指程序运行时间的最坏情况，所以要选择分支中运行时间较大的一方。
这种情况下，时间复杂度取决于分支中**运行时间较大**的一方的时间复杂度。

### Loop Statement
和*Conditional Statement*一样，多数程序中也都会有循环，如`for`和`while`。
循环有以下三种类型：

#### Linear Times Loop
```c
for (i = 0; i < n; ++i)
    statement1;
```

此时，程序总的运行时间为：
```
T(n) = n * t(statement1)
```
因为运行时间和n有关，时间复杂度为O(n)。

#### Constant Times Loop
```c
for (i = 0; i < 4; ++i)
    statement1；
```

此时，程序总的运行时间为：
```
T(n) = 4 * t(statement1)
```
因为循环的次数和n无关，时间复杂度为O(1)。

#### Nested Loops 
```c
for (i = 0; i < n; ++i)
    for (j = 0; j < m; ++j)
        statement1;
```

此时，程序总的运行时间为：
```
T(n) = n * m * t(statement1)
```
循环中嵌套了一层循环，时间复杂度为O(n²)。

### Function Call Statement

### Recursion
许多的算法都是以递归的方式进行描述的，所以学会计算递归程序的时间复杂度也很有必要。
计算方法有以下三种：

#### Guess Method
有些递归的时间复杂度是可以凭借经验猜测出来的。对于这些程序，我们可以先进行猜测，
再利用归纳法进行验证。例如，对于递归 
```
T(n) = 2T(n/2) + n
```

我们猜测它的时间复杂度为`T(n) = O(nLogn)`。然后利用归纳法进行验证：
```
证明：T(n) <= cnLogn

我们先假设对于任意的**k<n**，都有**T(k) <= cklogk**，则：

T(n) = 2T(n/2) + n
    <= 2cn/2Log(n/2) + n
     = cnLogn - cnlog2 + n
     = cnLogn - cn + n
    <= cnLogn
```

#### Recurrence Tree Method
这个算法可以描述为：
```
1. 根据递归表达式画出递归树
2. 计算每层的时间花销以及树总的深度
3. 计算最后一层的结点数以及时间花销
4. 计算总的时间花销
```

例如，对于表达式：
```
T(n) = T(n/10) + T(9n/10) + n
```

第一步，根据递归表达式画出递归树：
```
               T(n)
            /        \
    T(n/10)            T(9n/10)
    /    \            /        \
T(n/100)  T(9n/100)  T(9n/100)  T(81n/100)
   .          .          .           .
   .          .          .           .
   .          .          .           .
  T(1)       T(1)       T(1)        T(1)
```

第二步，计算每层的时间花销以及树总的深度：
```
每层的时间花销（找规律）
\1. n
\2. n/10 + 9n/10 = n
\3. n/100 + 9n/100 + 9n/100 + 81n/100 = n
...
k. n  (推测得出规律)

树总的深度：
找一条从根结点到叶子结点最长的路，因为我们知道最后一层的时间花销都为T(1)，
所以，如果我们要找**最长**的路，就得让*n*减小的尽可能慢，所以最长的路为：
n -> 9n/10 -> 81n/100 -> ... -> n(9/10)^k
所以，n(9/10)^k = 1 => k = log(10/9)(n)
所以，树总的深度为:log(10/9)(n)
```

第三步，计算最后一层的结点数以及时间花销：
```
可以看到，这个递归树为完全二叉树，所以最后一层的结点数为：2^(log(10/9)(n))

最后一层的花销为：2^(log(10/9)(n)) * T(1) = Θ((2^(log(10/9)(n)))) ~= Θ(n^7)
                                          = Θ((n^(log(10/9)(2))))
                                         ~= Θ(n^7)
```

第四步，计算总的时间花销：
总的时间花销为：
```
T(n) = n  +  n  +  ......  +  n  +  Θ((2^(log(10/9)(n)))) 
      \_(log(10/9)(n)-1)个n_/
     = n*log(10/9)(n) + Θ((2^(log(10/9)(n))))
     = O(n*log(10/9)(n))  (这个有疑问...)
```

#### Master Method

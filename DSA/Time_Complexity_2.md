# Time Complexity 2  时间复杂度 (2)

## 前言
这一篇记录递归程序的时间复杂度的求解方法。

## Recursion
许多的算法都是以递归的方式进行描述的，所以学会计算递归程序的时间复杂度也很有必要。
计算方法有以下三种：

### Guess Method
有些递归的时间复杂度是可以凭借经验猜测出来的。对于这些程序，我们可以先进行猜测，
再利用归纳法进行验证。例如，对于*divide-and-conquer*算法的递归表达式：
```
T(n) = 2T(n/2) + n
```

我们猜测它的时间复杂度为`T(n) = O(nlogn)`。然后利用归纳法进行验证：

证明：
```
T(n) <= cnlogn
```

首先，我们先对`n=1`进行讨论：
```
n = 1, T(1) <= clog1 = 0
```
因为 `T(1) = 1`，所以`n=1`不适用，需要单独说明。

再来讨论`n=2`：
```
n = 2, T(1) = 1

T(2)  = 2T(1) + 2
      = 4
     <= c2log2 = 2c, for c >= 2
```
显然，`n=2`可以适用。

假设在`n>=2`的情况下，对于任意的`k<n`，都有T(k) <= cklogk，则：
```
T(n) = 2T(n/2) + n
    <= 2(cn/2)log(n/2) + n
     = cnlogn - cnlog2 + n
     = cnlogn - cn + n
    <= cnlogn
```
证明完成。

### Recurrence Tree Method
这个算法可以描述为：

1. 根据递归表达式画出递归树
2. 把每层的花销相加求和

#### 例子一
对于表达式：
```
T(n) = T(n/10) + T(9n/10) + n
```

第一步，根据递归表达式画出递归树：
```
               T(n)
            /        \
    T(n/10)            T(9n/10)
    /    \            /        \
T(n/100)  T(9n/100)  T(9n/100)  T(81n/100)
   .          .          .           .
   .          .          .           .
   .          .          .           .
  T(1)       T(1)       T(1)        T(1)
```

第二步，把每层的花销相加求和：

先得到每层的时间花销（找规律）：
```
0. n
1. n/10 + 9n/10 = n
2. n/100 + 9n/100 + 9n/100 + 81n/100 = n
...
k. n  (推测得出规律)
```

再计算树总的深度：

找一条从根结点到叶子结点最长的路，因为我们知道最后一层的时间花销都为T(1)，
所以，如果我们要找最长的路，就得让n减小的尽可能慢，所以最长的路为：
```
n -> 9n/10 -> 81n/100 -> ... -> n(9/10)^k
```
因此，树总的深度为 `n(9/10)^k = 1 => k = log(10/9)(n)`。

所以总的花销为：
```
T(n)  = (k + 1) * n
      = (log(10/9)(n)+1) * n
     <= cnlog(n), for some constant c
```

这时候，我们就已经可以得出结论 `T(n) = O(nlogn)`。

#### 例子二
对于表达式：
```
T(n) = 3T(n/4) + cn^2
```

第一步，根据递归表达式画出递归树：
```
                     T(n)
               /       |     \
        T(n/4)      T(n/4)  T(n/4)
    /     |    \ 
T(n/16) T(n/16)  T(n/16)  ... ... 
   .      .          .
   .      .          .
   .      .          .
  T(1)   T(1)       T(1)
```

第二步，把每层的花销相加求和：

先得到每层的时间花销（找规律）：
```
0. cn^2
1. 3 c (n/4)^2 = cn^2(3/16)
2. 9 c (n/16)^2 = cn^2(3/16)^2
...
k. cn^2(3/16)^k  (推测得出规律)
```

再计算树总的深度：

找一条从根结点到叶子结点最长的路，因为我们知道最后一层的时间花销都为`T(1)`，
这里，每个非叶子节点都有三个结点，所以根节点到达每一个叶子节点的路径长度都相同，
因此，树总的深度为 `n/(4^k)=1 => k=log(4)(n)`。


所以总的花销为：
```
T(n)  = cn^2 (1 + 3/16 + (3/16)^2 + ... + (3/16)^(log(4)(n)))    # geometric series 几何数列
      = cn^2 ((3/16)^(log(4)(n)+1) - 1) / ((3/16) - 1)           # 错位相差求和
     <= cn^2 (-1) / ((3/16) - 1)                                 # n-> ∞ 以消除log(4)(n)的影响
      = dn^2, for some constant d
```

所以，此时我们可以得出：`T(n) = O(n^2)`。


### Master Method
这个方法就是属于规律性质的，只要符合使用条件，直接用公式求解，简单直接。

公式：
```
T(n) = aT(n/b) + f(n) where a >= 1 and b > 1
```

对于上述公式，有以下三种情况：
```
1. 如果 f(n) = O(n^c) 且 c < log(b)(a)，则 T(n) = Θ(n^(log(b)(a)))
2. 如果 f(n) = Θ(n^c) 且 c = log(b)(a)，则 T(n) = Θ(n^c logn))
3. 如果 f(n) = Ω(n^c) 且 c > log(b)(a), 且 对于 c >= 1 都有 af(n/b) < cf(n) 成立，则 T(n) = Θ(f(n))
```


## 参考文献
1. [the substitution method](http://homepages.math.uic.edu/~jan/mcs360f10/substitution_method.pdf)
2. [the recursion-tree method](http://homepages.math.uic.edu/~jan/mcs360f10/recursion_tree_method.pdf)

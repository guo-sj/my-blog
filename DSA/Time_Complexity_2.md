# Time Complexity 2  时间复杂度 (2)

## 前言
这一篇记录递归程序的时间复杂度的求解方法。

## Recursion
许多的算法都是以递归的方式进行描述的，所以学会计算递归程序的时间复杂度也很有必要。
计算方法有以下三种：

### Guess Method
有些递归的时间复杂度是可以凭借经验猜测出来的。对于这些程序，我们可以先进行猜测，
再利用归纳法进行验证。例如，对于递归 
```
T(n) = 2T(n/2) + n
```

我们猜测它的时间复杂度为`T(n) = O(nLogn)`。然后利用归纳法进行验证：
```
证明：T(n) <= cnLogn

我们先假设对于任意的**k<n**，都有**T(k) <= cklogk**，则：

T(n) = 2T(n/2) + n
    <= 2cn/2Log(n/2) + n
     = cnLogn - cnlog2 + n
     = cnLogn - cn + n
    <= cnLogn
```

### Recurrence Tree Method
这个算法可以描述为：
```
1. 根据递归表达式画出递归树
2. 计算每层的时间花销以及树总的深度
3. 计算最后一层的结点数以及时间花销
4. 计算总的时间花销
```

例如，对于表达式：
```
T(n) = T(n/10) + T(9n/10) + n
```

第一步，根据递归表达式画出递归树：
```
               T(n)
            /        \
    T(n/10)            T(9n/10)
    /    \            /        \
T(n/100)  T(9n/100)  T(9n/100)  T(81n/100)
   .          .          .           .
   .          .          .           .
   .          .          .           .
  T(1)       T(1)       T(1)        T(1)
```

第二步，计算每层的时间花销以及树总的深度：
```
每层的时间花销（找规律）
1. n
2. n/10 + 9n/10 = n
3. n/100 + 9n/100 + 9n/100 + 81n/100 = n
...
k. n  (推测得出规律)

树总的深度：
找一条从根结点到叶子结点最长的路，因为我们知道最后一层的时间花销都为T(1)，
所以，如果我们要找**最长**的路，就得让*n*减小的尽可能慢，所以最长的路为：
n -> 9n/10 -> 81n/100 -> ... -> n(9/10)^k
所以，n(9/10)^k = 1 => k = log(10/9)(n)
所以，树总的深度为:log(10/9)(n)
```

第三步，计算最后一层的结点数以及时间花销：
```
可以看到，这个递归树为完全二叉树，所以最后一层的结点数为：2^(log(10/9)(n))

最后一层的花销为：2^(log(10/9)(n)) * T(1) = Θ((2^(log(10/9)(n))))
                                          = Θ((n^(log(10/9)(2))))
                                         ~= Θ(n^7)
```

第四步，计算总的时间花销：
总的时间花销为：
```
T(n) = n  +  n  +  ......  +  n  +  Θ((2^(log(10/9)(n)))) 
      \_(log(10/9)(n)-1)个n_/
     = n*log(10/9)(n) + Θ((2^(log(10/9)(n))))
     = O(n*log(10/9)(n))
```

疑问：
```
1. 为什么最后一层的时间花销为**Θ(n^7)**而不是推测得出的规律**n**?
2. 为什么正确的答案是**O(n*log(10/9)(n))**，而不是**Θ(n^7)**(如果最后一层的时间花销真的是Θ(n^7)的话)?
```

### Master Method
这个方法就是属于规律性质的，只要符合使用条件，直接用公式求解，简单直接。

```
> T(n) = aT(n/b) + f(n) where a >= 1 and b > 1

有以下三种情况：
1. 如果 f(n) = O(n^c) 且 c < Log(b)(a)，则 T(n) = Θ(n^(Log(b)(a)))
2. 如果 f(n) = Θ(n^c) 且 c = Log(b)(a)，则 T(n) = Θ(n^c*Logn))
3. 如果 f(n) = Ω(n^c) 且 c > Log(b)(a), 且 对于 c >= 1 都有 af(n/b) < cf(n) 成立，则 T(n) = Θ(f(n))
```
